## Указатель на функцию и функциональный тип
Общий синтаксис описания типа указателя на функцию:
```cpp
return_type (*) (arg1_type, arg2_type, ... );
```
Например, функциональный тип указывающий на любую функцию, которая принимает один аргумент типа int и возвращает значение типа `float`:
```cpp
float (*) (int);
```

Для упрощения записи подобных типов создают синонимы
```cpp
using FuncIntFloat = float (*) (int);
// FuncIntFloat -- синоним
```

Эти функции соответствуют типу `FuncIntFloat`:
```cpp
float sqrt(int x){return pow(x,0.5);}
float foo(int x){return x*x * 22.0/7; }

// адреса функций можно записать в переменные типа FuncIntFloat
FuncIntFloat sq_root = &sqrt;
FuncIntFloat bar = &foo;
FuncIntFloat baz = foo;     // ? указывать не обязательно
```

Функциональный тип может быть аргументом другой функции
```cpp
/// выводит элементы массива, преобразуя их функцией f
void array_apply_n_print(int *arr, unsigned n, FuncIntFloat f){
    for (unsigned i=0; i<n; i++) {
        cout << f(arr[i]) << " ";
    }
}

int main(){
    unsigned N = 8;
    int* a = new int[N] {1,2,3,4,5,6,7,8};
    cout << endl;
    array_apply_n_print(a, N, sqrt);
    cout << endl;
    array_apply_n_print(a, N, foo);
    cout << endl;
    
    // вместо адреса созданной функции, можно передать анонимную функцию
    array_apply_n_print(a, N, [](int x)->float{return x;} );
    // функция [](int x)->float{return x;} возвращает свой аргумент неизменным
    
    cout << endl;
    
    array_apply_n_print(a, N, [](int x)->float{return x*x;} );
    // функция [](int x)->float{return x*x;} возвращает квадрат числа
    return 0;
}
```
Вывод программы:
```
1 1.41421 1.73205 2 2.23607 2.44949 2.64575 2.82843
0.318182 1.27273 2.86364 5.09091 7.95455 11.4545 15.5909 20.3636
1 2 3 4 5 6 7 8
1 4 9 16 25 36 49 64
```

## Анонимные функции
```cpp
[ захват ] ( параметры ) attr -> возвращаемый_тип { тело }
```
- Захват - глобальные переменные используемые функцией (по умолчанию не доступны),
- параметры - параметры функции; описываются как для любой функции, 
- mutable - указывается, если нужно поменять захваченные переменные, 
- исключения - которые может генерировать функция,
- атрибуты - те же что и для обычных функций.

#### Примеры анонимных функций:
Возведение аргумента в квадрат
```cpp
[](auto x) {return x*x;}
```
Сумма двух аргументов

```cpp
[](auto x, auto y) {return x + y;}
```
Возведение аргумента в квадрат
```cpp
[](auto x) {return x*x;}
```
Сумма двух аргументов
```cpp
[](auto x, auto y) {return x + y;}
```
Вывод в консоль числа и его квадрата
```cpp
[](float x) {cout << x << " " << x*x << endl;}
```

Тело лямбда-функции описывается также как и обычной функции
```cpp
[](int x) { if (x % 2) cout << "н"; else cout << "ч";}}
```


**Использование захвата**
`=` - захватить все переменные.
`&` - захватить переменную по ссылке.

Чтобы изменять переменную захваченную по ссылке нужно добавить
`mutable` к определению функции.
```cpp
float k = 1.2;
float t = 20;
[k](float x) {return k*x;}
[k,&c](float x) mutable {if (k*x > 0) c = 0; else c=k*x;}
```

Анонимные функции без захвата имеют могут быть записаны в переменные (переданы как аргументы) если тип переменной (аргумента) совпадает с типами аргументов и возвращаемого значения функции.

При этом будет неявно сделано преобразование, чтобы соответствовать функциональному типу. 

Например
```cpp
float sum(float a, float b){return 0.0;}

float(*func1)(float, float) =  [](auto x, auto y) {return x + y;};
float(*func2)(float, float) = &sum;
```
func1, func2 - название переменных-указателей на функции.\


Но анонимные функции с захватами (capturing) преобразования к типу указатель на функцию не допускают.

Например
```cpp
// Ошибка компиляции!
float(*func3)(float, float) =  [=](auto x, auto y) {return x + y;};
```

**Когда использовать лямбда функции?**
- Когда не требуется объявлять функцию заранее.
- Функция очень короткая.
- Функция нужна один раз.
- Функцию лучше всего описать там, где она должна использоваться.

См. также inline функции.


#### Примеры использования decltype и auto для указателей на функции
...

#### std::function
Тип `std::function` — это универсальный обёрточный класс (type erasure), способный хранить любые callable-объекты (функции, функции-объекты, лямбды, std::bind, указатели на методы и даже указатели на данные).
Он предоставляют более удобный вариант передачи функций в качестве аргументов, в том числе анонимных функций с захватом внешних переменных.


```cpp
/// перебирает значения элементов массива arr размером n,
/// для каждого элемента вызывает функцию void apply_to_array(int * arr, unsigned n, 
std::function<void(int&)> f){
    // std::function<void(int&)> -- указатель на функцию, возвращающую void,
    // принимающую int по ссылке
    for (unsigned i = 0; i < n; ++i)
        f( arr[i] );
}


int a[] ={1,2,3,4,5,6};
apply_to_array(a, 6, [](int &x){cout << x << " ";});
cout << "\n";
apply_to_array(a, 6, [](int &x){cout << x*x << " ";});
cout << "\n";
apply_to_array(a, 6, [](int &x){x = x+1;});
apply_to_array(a, 6, [](int &x){cout << x << " ";});
cout << "\n";
// взаимодействие с внешними переменными:
stack<int> S;
apply_to_array(a, 6, [&S](int &x){S.push(x);});
// [&S] - захват, позволяет использовать внешние переменные;
// в данном случае функции доступна ссылка на S
```

Однако при вызове таких функций, из значений типа `std::function` возникают накладные расходы, поэтому при высоких требованиях к производительности их использование нежелательно.

#### Функции как шаблонный тип
Шаблонные функции (`template<typename F> void apply(F&& f, …)`) обладают гибкостью (любой callable) как и `std::function`, при этом компиляция инстанцирует конкретный код под каждую лямбду, что избавляет от type erasure во время выполнения.