## Указатель на функцию и функциональный тип
Общий синтаксис описания типа указателя на функцию:
```cpp
return_type (*) (arg1_type, arg2_type, ... );
```
Например, функциональный тип указывающий на любую функцию, которая принимает один аргумент типа int и возвращает значение типа `float`:
```cpp
float (*) (int);
```

Для упрощения записи подобных типов создают синонимы
```cpp
using FuncIntFloat = float (*) (int);
// FuncIntFloat -- синоним
```

Эти функции соответствуют типу `FuncIntFloat`:
```cpp
float sqrt(int x){return pow(x,0.5);}
float foo(int x){return x*x * 22.0/7; }

// адреса функций можно записать в переменные типа FuncIntFloat
FuncIntFloat sq_root = &sqrt;
FuncIntFloat bar = &foo;
FuncIntFloat baz = foo;     // ? указывать не обязательно
```

Функциональный тип может быть аргументом другой функции
```cpp
/// выводит элементы массива, преобразуя их функцией f
void array_apply_n_print(int *arr, unsigned n, FuncIntFloat f){
    for (unsigned i=0; i<n; i++) {
        cout << f(arr[i]) << " ";
    }
}

int main(){
    unsigned N = 8;
    int* a = new int[N] {1,2,3,4,5,6,7,8};
    cout << endl;
    array_apply_n_print(a, N, sqrt);
    cout << endl;
    array_apply_n_print(a, N, foo);
    cout << endl;
    
    // вместо адреса созданной функции, можно передать анонимную функцию
    array_apply_n_print(a, N, [](int x)->float{return x;} );
    // функция [](int x)->float{return x;} возвращает свой аргумент неизменным
    
    cout << endl;
    
    array_apply_n_print(a, N, [](int x)->float{return x*x;} );
    // функция [](int x)->float{return x*x;} возвращает квадрат числа
    return 0;
}
```
Вывод программы:
```
1 1.41421 1.73205 2 2.23607 2.44949 2.64575 2.82843
0.318182 1.27273 2.86364 5.09091 7.95455 11.4545 15.5909 20.3636
1 2 3 4 5 6 7 8
1 4 9 16 25 36 49 64
```

## Анонимные функции
```cpp
[ захват ] ( параметры ) attr -> возвращаемый_тип { тело }
```
- Захват - глобальные переменные используемые функцией (по умолчанию не доступны),
- параметры - параметры функции; описываются как для любой функции, 
- mutable - указывается, если нужно поменять захваченные переменные, 
- исключения - которые может генерировать функция,
- атрибуты - те же что и для обычных функций.

#### Примеры анонимных функций:
Возведение аргумента в квадрат
```cpp
[](auto x) {return x*x;}
```
Сумма двух аргументов

```cpp
[](auto x, auto y) {return x + y;}
```
Возведение аргумента в квадрат
```cpp
[](auto x) {return x*x;}
```
Сумма двух аргументов
```cpp
[](auto x, auto y) {return x + y;}
```
Вывод в консоль числа и его квадрата
```cpp
[](float x) {cout << x << " " << x*x << endl;}
```

Тело лямбда-функции описывается также как и обычной функции
```cpp
[](int x) { if (x % 2) cout << "н"; else cout << "ч";}}
```


**Использование захвата**
`=` - захватить все переменные.
`&` - захватить переменную по ссылке.

Чтобы изменять переменную захваченную по ссылке нужно добавить
`mutable` к определению функции.
```cpp
float k = 1.2;
float t = 20;
[k](float x) {return k*x;}
[k,&c](float x) mutable {if (k*x > 0) c = 0; else c=k*x;}
```

Анонимные функции без захвата имеют могут быть записаны в переменные (переданы как аргументы) если тип переменной (аргумента) совпадает с типами аргументов и возвращаемого значения функции.

При этом будет неявно сделано преобразование, чтобы соответствовать функциональному типу. 

Например
```cpp
float sum(float a, float b){return 0.0;}

float(*func1)(float, float) =  [](auto x, auto y) {return x + y;};
float(*func2)(float, float) = &sum;
```
func1, func2 - название переменных-указателей на функции.\


Но анонимные функции с захватами (capturing) преобразования к типу указатель на функцию не допускают.

Например
```cpp
// Ошибка компиляции!
float(*func3)(float, float) =  [=](auto x, auto y) {return x + y;};
```

**Когда использовать лямбда функции?**
- Когда не требуется объявлять функцию заранее.
- Функция очень короткая.
- Функция нужна один раз.
- Функцию лучше всего описать там, где она должна использоваться.

См. также inline функции.


**Функция высшего порядка (higher-order function)** — это функция, которая принимает в качестве аргумента другую функцию или возвращает функцию как результат. В примере ниже это apply_to_array.

#### Примеры использования decltype и auto для указателей на функции
...

#### std::function
Тип `std::function` — это универсальный обёрточный класс (type erasure), способный хранить любые callable-объекты (функции, функции-объекты, лямбды, std::bind, указатели на методы и даже указатели на данные).
Он предоставляют более удобный вариант передачи функций в качестве аргументов, в том числе анонимных функций с захватом внешних переменных.


```cpp
/// перебирает значения элементов массива arr размером n,
/// для каждого элемента вызывает функцию 
void apply_to_array(int * arr, unsigned n,  std::function<void(int&)> f){
    // std::function<void(int&)> -- указатель на функцию, возвращающую void,
    // принимающую int по ссылке
    for (unsigned i = 0; i < n; ++i)
        f( arr[i] );
}


int a[] ={1,2,3,4,5,6};
apply_to_array(a, 6, [](int &x){cout << x << " ";});
cout << "\n";
apply_to_array(a, 6, [](int &x){cout << x*x << " ";});
cout << "\n";
apply_to_array(a, 6, [](int &x){x = x+1;});
apply_to_array(a, 6, [](int &x){cout << x << " ";});
cout << "\n";
// взаимодействие с внешними переменными:
stack<int> S;
apply_to_array(a, 6, [&S](int &x){S.push(x);});
// [&S] - захват, позволяет использовать внешние переменные;
// в данном случае функции доступна ссылка на S
```

Однако при вызове таких функций, из значений типа `std::function` возникают накладные расходы, поэтому при высоких требованиях к производительности их использование нежелательно.

В `std::function` хранится указатель на функцию-обёртку, вызывающую оригинальный callable, и, возможно, дополнительная память для захваченных данных. Пользователь работает только с `std::function<R(Args…)>`, не зная о том, что внутри — лямбда, функтор или указатель на функцию. Такой подход называется ***type-erasure***.


#### Callable
callable — это тип, для которого определены операции INVOKE и INVOKE<R> (используемые `std::invoke`, `std::function`, `std::bind` и т. д.):

- Функция - указатель R(*)(Args…).
- Функтор - объект класса с перегруженным operator().
- Лямбда
- Члены класса - через std::mem_fn или std::bind можно превратить указатель на метод в callable.

#### Функции как шаблонный тип
Шаблонные функции (`template<typename F> void apply(F&& f, …)`) обладают гибкостью (любой callable) как и `std::function`, при этом компиляция инстанцирует конкретный код под каждую лямбду, что избавляет от type erasure во время выполнения.


```cpp
#include <cstddef>

template<typename F>
void apply(F&& f, float* array, std::size_t n) {
    for (std::size_t i = 0; i < n; ++i)
        array[i] = std::forward<F>(f)(array[i]);
}

// Пример вызова:
apply([](float x){ return x * x; }, data, N);

```

## Функторы

...



Функтор (function object) — это объект класса или структуры, для которого перегружен оператор вызова `operator()`, благодаря чему такой объект можно вызывать как функцию.

В отличие от обычных функций или указателей на функцию, функторы могут хранить состояние (поля-члены), подлежат инлайн-оптимизации компилятором и широко используются в алгоритмах STL.

```cpp
#include <iostream>
struct Greet {
    void operator()() const {
        std::cout << "Hello, World!\n";
    }
};

int main() {
    Greet greet;
    greet();             // выводит "Hello, World!"
}
```

Функтор с аргументами:
```cpp
#include <iostream>
struct Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};

int main() {
    Add add;
    std::cout << add(3, 4);  // выводит 7
}
```


Функтор с состоянием
```cpp
#include <iostream>
struct Accumulator {
    int sum;
    Accumulator(int init) : sum(init) {}
    int operator()(int x) {
        sum += x;
        return sum;
    }
};

int main() {
    Accumulator acc(10);
    std::cout << acc(5) << '\n';   // 15
    std::cout << acc(3) << '\n';   // 18
}
```

### Comparator
В C++ компаратор — это callable-объект, задающий правило сравнения двух элементов для алгоритмов сортировки и контейнеров (std::sort, std::set, std::priority_queue и т. д.). Компаратор может быть указателем на функцию, функтором (function object) или лямбдой.


Встроенные компараторы из `<functional>`
Стандартная библиотека предоставляет набор готовых function objects:
- std::less<T> — вызов lhs < rhs (Cppreference)
- std::less_equal<T> — lhs <= rhs (Cppreference)
- std::greater<T> / std::greater_equal<T> — обратные операции


Примеры:
```cpp
std::sort(v.begin(), v.end()); 
// использует std::less<T>()
```
[Cppreference](https://en.cppreference.com/w/cpp/algorithm/sort?utm_source=chatgpt.com)


```cpp
std::vector<int> v = {4,3,5,1,2};
std::sort(v.begin(), v.end(), [](int a,int b){ return a>b; });  
```


Использование компаратора при объявлении контейнера:
```cpp
std::priority_queue<int, std::vector<int>, std::less<>> pq;
```

## Паттерн Стратегия
todo:


# См. также
- Классы Callable, Runnable, Functional и др. в Java
