# Система сборки CMake

Для компиляции простых программ достаточно вызывать только команду компиляции, например:
```bash
g++ main.cpp unit.cpp -o my_program 
```
Более сложные программы обычно полагаются на внешние библиотеки, наборы дополнительных файлов (файлы с данными, файлы настроек, изображения и т.д.).
Иногда такие программы компилируют частями, разбивая их на отдельные модули. 
Таким образом, процесс компиляции может включать в себя несколько запусков компилятора с различными файлами и настройками, 
с учётом расположения ранее скомпилированных частей программы, очистку папок от временных файлов, 
копирование уже готовой программы и её файлов в отдельный, от файлов исходного кода, каталог.

**Система автоматизации сборки** -- набор программ, призванных упростить компиляцию кода, с учётом параметров компилятора, 
зависимостей кода (других библиотек), выполнения модульных тестов, очистки проекта от временных файлов и т.п. 
Система сборки полагается на специальные конфигурационные файлы, которые описывают состав проекта и процесс его компиляции. 
Большинство современных IDE при компиляции программы не вызывают компилятор напрямую, а обращаются к системе сборки. 
Например Qt Creator и CLion полагаются на CMake.

**CMake** -- система сборки, которая позволяет автоматизировать компиляцию программ и их частей (сконфигурировать команды компиляции), 
выполнение тестов, развёртывание программы и т.п. Конфигурация сборки описывается в файле CMakeLists.txt

CMake используется средами разработки Qt Creator, CLion и др.

### Основные понятия
В основе файлов конфигурации cmake лежат **цели (targets)**. Целями могут выступать например: 
- компиляция исполняемого файла (add_executable);
- компиляция библиотеки  (add_library);
- включить в текущий проект, другой cmake проект (add_subdirectory).

Для задания цели нужно указать ей тип, задать или указать название и указать основные файлы исходного кода.

Помимо задания цели можно определить название **проекта**, его описание и свойства (`project( ... )`). **Параметры** метакомпилятора (`set( var value)`  или `add_compile_options(-O2)`. CMake не привязан к конкретному компилятору, поэтому можно задавать параметры (например версию стандарта C++) в формате предусмотренным CMake.

Многие параметры задаются через специальные **переменные** командой set, например `set(CMAKE_CXX_STANDARD 20)`. Обращаться к переменным, например так: `${PROJECT_NAME}`

Если программа использует хранит файлы исходного кода или библиотеки в других папках, то указываются **дополнительные пути**, после того как задана цель компиляции:
- для исходных файлов (`target_include_directories ( ... ) `), которые передаются компилятору;
- для скомпилированных файлов библиотек (`target_link_directories ( ... )`, `target_link_libraries(...)`), которые передаются компоновщику (линковщику) [см. этапы компиляции С++ программы]

Наконец можно указать **папку для сохранения выходных файлов**: `set (CMAKE_RUNTIME_OUTPUT_DIRECTORY bin)`

Если необходимо, можно скопировать файлы из папки с исходниками в папку сборки. Например
```CMake
configure_file(data/my_data.txt ${CMAKE_CURRENT_BINARY_DIR}/bin/data/my_data.txt)
```
копирует файл `data/my_data.txt` в каталог сборки (`${CMAKE_CURRENT_BINARY_DIR}`). Если необходимо, в новом месте создаётся папка.

Рекомендуется разделять как минимум папку с файлами исходного кода и папку сборки, где будет создан, например, исполняемый файл проекта. 

## Hello, World

Рассмотрим простую программу **main.cpp**
```C++
#include <iostream>
using namespace std;

int main(){
	cout << "Hello, World\n"; }
```
Создадим простой файл конфигурации сборки `CMakeLists.txt`
```cmake
# add_executable -- цель -- создание исполняемого файла
add_executable(                         
  hello_world                       # имя выходного файла = имя проекта
  main.cpp                          # Список файлов исходного кода
)
```

**Сборка**

Структура проекта:
```
my_project
   |-- src
   |   |-- main.cpp
   |   |-- CMakeLists.txt
```

Подготовка сборки, `.` - имя текущего каталога.
```bash
cmake -B ../my_build .
```
- `-B ../my_build` - путь из папки с файлом CMakeLists.txt к папке, где будет происходить сборка. Если не указать, то большое количество служебных файлов сборки будут созданы прямо в текущем каталоге.

Сборка:
```bash
cmake --build ../my_build 
```

В результате получится структура проекта
```
my_project
   |-- src
   |   |-- main.cpp
   |   |--CMakeLists.txt
   |-- my_build
   |   |-- ...служебные файлы и папки ...
   |   |-- my_project.exe
```


## Расширенный пример
Более сложный файл конфигурации сборки `CMakeLists.txt`
```cmake
cmake_minimum_required(VERSION 3.24)			# требуемая версия CMake

# название проекта my_project и его версия
project(my_project VERSION 1.5)

# настройки компилятора
# set(CMAKE_CXX_COMPILER "g++-12")         		# имя компилятора (можно указать полный путь)
set(CMAKE_CXX_STANDARD 20)               		# версия стандарта языка
# set(CMAKE_CXX_STANDARD_REQUIRED True)  		# включает проверку: задана ли явно версия стандарта языка
add_compile_options(-O2)                 		# другие опции компиляции: второй уровень оптимизации кода


# папка для сохранения исполняемого файла: bin
# стоит указать, чтобы отделить от служебных файлов генерируемых CMake
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY bin)

# add_executable -- цель -- создание исполняемого файла
add_executable(                         
  ${PROJECT_NAME}                        # имя файла = имя проекта
  main.cpp                               # Список файлов исходного кода через пробел
)


# если нужно: дополнительная папка для поиска файлов исходного кода (cpp и h) 
# должна быть указана после того, как указана цель сборки add_executable или add_librarie
# target_include_directories(${PROJECT_NAME} PUBLIC include)
# Второй аргумент задаёт видимость включаемых файлов для проектов, использующих данный (если они есть)
```


В результате получится структура проекта
```
my_project
   |-- src
   |   |-- main.cpp
   |   |--CMakeLists.txt
   |-- my_build
   |   |-- ...служебные файлы и папки ...
   |   |-- my_project.exe
   |   |-- bin
   |   |   |-- my_project.exe
```


# Загрузка зависимостей

Пример:
```
# Подключает модуль FetchContent для CMake
# FetchContent используется для загрузки внешних зависимостей, входит в состав CMake 3.11+
include(FetchContent)

# Объявление зависимости
FetchContent_Declare(
        googletest
        URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip
)

# Загрузка зависимости
FetchContent_MakeAvailable(googletest)
```

# Тестирование
Пример проекта из двух файлов `main_test.cpp` (основная программа) и `main_test.cpp` (файл с тестом). Тест использует фреимворк GoogleTest.
```cmake
cmake_minimum_required(VERSION 3.24)    # требование к минимальной версии CMake

project(executable_with_test)           # название проекта

set(CMAKE_CXX_STANDARD 23)                          # Стандарт С++23

# Указание цели сборки: исполняемый файл
# executable_with_test -- имя цели = имя исполняемого файла
# main.cpp -- список файлов исходного кода, необходимых для компиляции
add_executable(executable_with_test main.cpp)


# ========================================================================================  Настройка тестирования
# Подключает модуль FetchContent для CMake
# FetchContent используется для загрузки внешних зависимостей, входит в состав CMake 3.11+
include(FetchContent)
# Объявление зависимости
FetchContent_Declare(
        googletest
        URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip
)
# Загрузка зависимости
FetchContent_MakeAvailable(googletest)


# добавление ещё одной цели -- исполняемый файл main_test для теста
add_executable(main_test main_test.cpp)
# для компиляции файла с тестами нужна дополнительная библиотека GoogleTest,
# добавим её как составную часть цели main_test
target_link_libraries( main_test  GTest::gtest_main)

# сделать тест частью проекта
enable_testing()
# Подключает модуль GoogleTest для CMake
include(GoogleTest)
# Запустить файл main_test чтобы получить имена тестов (но не выполнить тесты)
gtest_discover_tests(main_test)
```

main.cpp
```C++
int main() {
    return 0; }
```

main_test.cpp
```c++
#include <gtest/gtest.h>

// Пример тестовой функции
TEST(HelloTest, BasicAssertions) {

	EXPECT_STRNE("hello", "world");		// проверка неравенства строк
	EXPECT_EQ(7 * 6, 42);				// проверка равенства чисел
}
```

**Сборка**
```bash
# подготовка к сборке в каталог build
cmake -B build .
# сборка в каталог build
cmake --build build

# запуск тестов
cmake -B build .
```

Как правило для тестов создаётся отдельный файл конфигурации CMake, который потом включается в основной файл проекта. 

## См. также
Папки с примерами в этом каталоге

# Ссылки
- https://cliutils.gitlab.io/modern-cmake/
- Учебник: Система построения проектов CMake, Д. В. Дубровов
